#Empty Namespace
class Tiles::Factories < Tiles::ClassSpace
	
end
class Tiles::Time
end
# Functional Space for generation time classes
class Tiles::Factories::TimeFactory < BasicObject
	def self.generate_timespace(opts = {})
		# /regex/ => [array_of_equations] => regex is cast on string and equations in 
		#					the array are operated on the context of the results
		# 'to_s' => ["%s %w %q", :days, :weeks, :years] (Definition of to String from string format)
		# Symbol => String/Proc   (define the function Symbol that casts the time value using String as a Equation)
		#			ex. :today => { |raw| %w[Monday Tuesday Wendsday Thursday ....][raw % 7] } (block)
		#			ex. :days  => :raw (default reference)
		#			ex. :months => "raw % 30" (Equation)
		# 'valid_units'	=> Array  (of the listed Symbols that themselves are valid units)
		#				This allows for "dimensional analysis" i.e "years = date - month - day"
		# 'default_value' => value	(Time.new without passed value defaults to this value)
		from_string = nil
		funcs = []
		default = nil
		to_string = nil
		to_s_param = []
		valid_units = []
		opts.each_pair do |key,value|
			case key
				when Regexp then from_s = value
				when Symbol then valid_units.push value 
				when 'to_s','to_string' then (value.is_a?(Array) ) ? 
					(to_string = value.unshift; to_s_param = value ) : to_string = value
				when 'valid_units' then valid_units = value
				when 'default_value' then default = value
				else raise "Invalid option to method opt:#{key} => #{value}"
			end
		end
		### Sanitize
		raise "Invalid to_string option. 
			Given object is not a valid way of calling sprintf(*to_string)".delete("\t\n")	if to_string.nil? or 
				to_s_param.any? {|ele| !ele.is_a? Symbol && !ele.respond_to?(:to_sym) }
		raise "Invalid parameters for to_string must be valid functions 
			on the timespace (i.e a must be :raw or a provided function) #{to_s_param}"
				.delete("\t\n") if to_s_param.any? { |ele| opt[ele.to_sym].nil?  }
		raise "No from_string method provided" if from_string.nil?
		raise "Provided a valid unit that is not generated by a function 
			provided and doesn't exist in the namespace 
			of Object or Time".delete("\t\n") if valid_units.any? { |e| !e.is_a?(Class) && !const_defined?(e.to_sym,true) } 
		#TODO: Include Defined to_string / from_string function requirements on default_value
		
	end
end
class Tiles::Factories::ComparableFactory
# Ex.
# a = ((((Tiles::Factories::ComparableFactory.blank_factory(:name =>'::LingComp') < 
#		:before < :now  < :after).move_to(:now) == :present) < :future ) == :after).generate
# a = Tiles::Factories::ComparableFactory.construct('lg') { |f| f[Fixnum] <=> f[Fixnum]; f[:now,Fixnum] === f[Fixnum] ; f[:before,Fixnum] < f[Fixnum] }
# ^ Generates a Comparision Space with :fore being less than :now and :present which are less than :after 
	@@space_list ||= {}
	private_class_method :new
##### Class Methods
	def self.blank_factory(opts ={})
		new(opts)
	end
	def self.construct(name,opts = {},&blk)
		a =  new(name) if block_given? || !blk.nil?	
		(block_given?) ? yield(a) : blk.call(a)
		(!opts[:generate_after].nil? && opts[:generate_after] == false)? a : a.generate
	end
	def self.[](name)
		@@space_list[name.to_s]
	end
	private
	def self.register_space(name,space,make_global = false)
		@@space_list[name.to_s] = space
	end
	public
	attr_reader :space,:pobj,:plvl
	def initialize(name)
		@name = name.to_s
		@space = [_new_space]
		@pobj = nil
		@plvl = 0
		# Hash Method
		@spacehash = {}
		@instances = []
		@sets	   = []
		
	end
	def [](*args)
		Worker.new(self,args)	
	end
	def generate
		kl = @spacehash.keys
		ml = kl.collect { |k| k.max_by {|i| i.length }.length }.max
		isl = (0...ml).collect { |l| kl.collect { |k| [k[0][-l-1], k[1][-l-1]] }.flatten.uniq }
		islh = {}; isl.flatten.each { |ent| islh[ent] = [nil,0] }
		kl.reject {|k| @spacehash[k] != -1 }.each { |k| (0...ml).each { |l| islh[k[0][-l-1]] = [k[1][-l-1], -1]  if k[0][-l-1] != k[1][-l-1] }     }
		islh[nil] = 0
		islh.each_pair  { |k,v| islh[k] = islh[v[0]] + v[1] if v.is_a?(Array) && islh[v[0]].is_a?(Fixnum) } while islh.values.any? {|v| v.is_a? Array }
		@lvlhash = islh
		self
	end
	# Positive definite hash?
	def coordinate_workers(wk1,wk2,dir)
		_workers_belong_to_me?(wk1,wk2) #This raises an error on failure
		@spacehash[[wk1.param,wk2.param]] = dir
		#@spacehash[[wk2.param,wk1.param]] = (dir.is_a?(Fixnum))? 0 - dir : dir
		[wk1.param,wk2.param].flatten(1).each { |ele| (ele.is_a?(Class))? @sets.push(ele) : @instances.push(ele) if (@sets + @instances).index(ele).nil? }
	end
	def compare(s1,s2)
		s1 = [s1] unless s1.is_a? Array
		s2 = [s2] unless s2.is_a? Array
		for i in 1..([s1.length,s2.length].max)
			p1 = s1.last(i).collect {|e| _get_closest_membership(e)}
			p2 = s2.last(i).collect {|e| _get_closest_membership(e)}
			result = case @spacehash[  [ p1 , p2  ]  ]
				when Fixnum	 then @spacehash[[p1,p2]]
				when Symbol	 then  (0...i).inject(0) {|r,i2| (r == 0) ? s1[-1 - i2] <=> s2[-1 - i2] : r   } 
				when nil	 then s1.reverse <=> s2.reverse # Use the comparator from each object 
										# Array's default <=> returns the result
										# of the first nonequal pair 
										# We are using arrays in terms of lexical priority 
										#(i.e each object modifies the next thus last is highest value) 
				else 		 raise "Something Bad Happened. Not quite sure what..."
			end
			break if result != 0 && result != nil
		end
		result
	end
##### Instance methods 
	## Comparision generation
	# Calls the insertion function with spaceship operator values (1,0,-1) 
	#########
	## Space Level operators
	def cspace
		@space[@plvl]
	end
	private
	class Worker #Construction worker
		attr_reader :factory, :param
		def initialize(factory,args)
			@factory = factory
			@param = args
		end
		def <(obj); 	@factory.coordinate_workers(self,obj,-1); 	end
		def >(obj); 	@factory.coordinate_workers(self,obj,1); 	end
		def ===(obj);	@factory.coordinate_workers(self,obj,0); 	end
		def <=>(obj); 	@factory.coordinate_workers(self,obj,:<=>);		end
	end

	def _new_space
		{:uplvl => nil, :objs => [], :<=> => [], :max_repeat => 0 }
	end

	def _workers_belong_to_me?(wk1,wk2)
		raise "Attempted to generate a comparison space using *Worker*s bound 
			to different factories (or not bound to a factory). 
			#{wk1}.factory != #{wk2}.factory".delete("\t\n") if wk1.factory != wk2.factory || wk1.factory != self
	rescue NoMethodError => e
		raise e, "One of the input workers is not a #{self.class}::Worker." 
	end

	def _get_closest_membership(item)
		if @instances.index(item) 
			item
		else 
			@sets.find_all { |s| item.is_a? s }.sort[0] # Should be closest ancestor
		end
	end
	def _sorted_lvl(lvl,n)
		less_than_hash = @spacehash.keys.reject {|k|  @spacehash[k] != -1 || k[0].last(1+n).length != (1+n) }
							.inject({}) { |hsh,k| (hsh[k[0][n]] ||= []).push(k); hsh } 
		lvl = lvl.sort_by { |ent| less_than_hash[ent].length }
	end
	
end
